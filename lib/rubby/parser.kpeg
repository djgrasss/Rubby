%% name = Rubby::Parser

%% {
  def ast
    @ast || @result
  end
}

%% ast-location        = Rubby::Nodes
%% comment             = ast Comment(value)
%% integer             = ast Integer(value)
%% float               = ast Float(value)
%% constant            = ast Constant(value)
%% string              = ast String(values)
%% simple_string       = ast SimpleString(value)
%% call                = ast Call(name, arguments)
%% array               = ast Array(values)
%% hash                = ast Hash(values)
%% hash_element        = ast HashElement(key, value)
%% symbol              = ast Symbol(value)
%% regex               = ast Regex(values,mods)
%% regex_seq           = ast RegexSeq(value)
%% interpolation       = ast Interpolation(expression)
%% expression_group    = ast ExpressionGroup(expression)
%% call_argument       = ast CallArgument(expression)
%% call_argument_splat = ast CallArgumentSplat(expression)
%% call_with_block     = ast CallWithBlock(call,statements)

eof = !.
space = " " | "\t"
nl = "\n" | "\r" | "\r\n" | "\n\r"

keywords = "module" | "class" | "if" | "else" | "elsif" | "unless"
rejected = "do" | "and" | "or" | "not" | "return" | "proc" | "lambda"

# Keywords
module = "module"
class  = "class"
if     = "if"
else   = "else"
elsif  = "elsif"
unless = "unless"
raise  = "raise" | "o_O"
rescue = "rescue"
ensure = "ensure"
proc   = "&>"

# Literals
identifier = /[a-z_][a-zA-Z0-9_]*/

constant_name     = /([A-Z][a-zA-Z0-9_]+)/
constant_sep      = "::"
constant_with_sep = constant_sep constant_name
constant   = < (constant_name constant_with_sep+) | constant_with_sep+ | constant_name > ~constant(text)

integer_octal   = /(0[1-9][0-9]*)/
integer_decimal = /([1-9][0-9]*)/
integer_zero    = "0"
integer_hex     = /(0x[0-9a-fA-F]+)/
integer_binary  = /(0b[01]+)/
integer    = < integer_octal | integer_decimal | integer_hex | integer_binary | integer_zero > ~integer(text)
float      = < /([0-9]+\.[0-9]+)/ > ~float(text)

# Strings
single_tick_string = "'" simple_string_seq:value "'" ~string([value])
simple_string_seq = </(\\'|[^'])/*> ~simple_string(text)

string_seq        = < /[^\\"]+/ > ~simple_string(text)
double_tick_string = "\"" (interpolated_expression:s | string_seq:s)*:values "\"" ~string(values)
string     = single_tick_string | double_tick_string

# Regular expressions
regex_seq  = < /[^\\\/]+/ > ~regex_seq(text)
regex_mods = "i" | "m" | "x" | "o"
regex      = "/" (interpolated_expression:s | regex_seq:s)*:values "/" regex_mods*:mods ~regex(values,mods)

# Interpolation
interpolation_begin = "#{"
interpolation_end   = "}"
interpolated_expression = interpolation_begin space? expression:expr space? interpolation_end ~interpolation(expr)

# Array literals
array_empty     = "[]" ~array([])
array_non_empty = "[" space? <expression_list:values> space? "]" ~array(values)
array           = array_non_empty | array_empty

# Hash literals
hash_sep          = ":" space?
hash_lhs_symbol   = identifier:name ~symbol(name)
hash_valid_lhs_exprs = hash_braced | call | regex | array | identifier | constant | float | integer | string | symbol
hash_lhs_expr     = hash_valid_lhs_exprs | expression_group
hash_lhs          = hash_lhs_expr | hash_lhs_symbol
hash_element      = hash_lhs:key hash_sep expression:value ~hash_element(key,value)
hash_element_list = (hash_element (expression_list_sep hash_element)+) | hash_element
hash_unbraced     = hash_element_list:values ~hash(values)
hash_braced       = "{" space? hash_element_list:values space? "}" ~hash(values)
hash_empty        = "{" space? "}" ~hash([])
hash              = hash_unbraced | hash_braced | hash_empty

# Symbol literals
symbol_identifier = /[A-Za-z0-9_]+/
symbol_ident      = <symbol_identifier> ~symbol(text)
symbol_string     = string:value ~symbol(value)
symbol_glyph      = <("+" | "-" | "*" | "/" | "!" | "^" | "&" | "**")> ~symbol(text)
symbol_var        = <("@@" | "@") symbol_identifier> ~symbol(text)
symbol            = ":" (symbol_ident | symbol_string | symbol_glyph | symbol_var)

# Comments
comment    = "#" < (!nl .)* > nl ~comment(text)

# Method call_args
call_arg_splat = "*" expression:expr ~call_argument_splat(expr)
call_arg_expr  = expression:expr ~call_argument(expr)
call_arg       = call_arg_expr | call_arg_splat
call_arg_sep   = space? "," space?
call_args      = (call_arg (call_arg_sep call_arg)+)

# Method Calls
call_without_args       = <identifier:name> ( "(" space? ")" )? ~call(name, [])
call_with_braced_args   = <identifier:name "(" space? call_args:args space? ")"> ~call(text, args)
call_with_unbraced_args = <identifier:name space? call_args:args space?> ~call(name, args)
call_without_block      = call_with_braced_args | call_with_unbraced_args | call_without_args
call_with_block         = call_without_block:call space? proc ~call_with_block(call,nil)
call                    = call_with_block | call_without_block

expression_list_sep = space? "," space?
expression_list     = (expression (expression_list_sep expression)+) | expression
expression_group    = "(" space? expression:expr space? ")" ~expression_group(expr)
expression_item     = hash | call | regex | array | identifier | constant | float | integer | string | symbol

expression = expression_group | expression_item
statements = statement+
statement_end = nl | eof #| indent | outdent
statement  = (expression | comment) statement_end
root       = statements
